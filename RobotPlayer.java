package team097;

import battlecode.common.*;
import java.util.*;

public class RobotPlayer
{
	public static RobotController rc;
	static Random randomThing = new Random();
	static Direction allDirections[] = Direction.values();
	static int robotsProduced;
	static MapLocation farm1;
	static MapLocation farm2;
	static double[][] cowsOnMap;
	static int noisetowerDirTracker = 0;
	static int noisetowerFireTracker = 4;
	static int pastrsProduced; //if we find this to be much higher than our number of current pastrs, we know our opponent is aggresively targeting our pastrs. Any surving pastrs should be defended, and we should probably consider not building more.
	static ArrayList<MapLocation> route = new ArrayList<MapLocation>(); //the route generated by a*
	static boolean routeMapped = false; //this is just being used a in my test function for pathing. We'll want to remove it and replavve it with something better.
	
	public static void run(RobotController rcin)
	{
		rc = rcin;
		randomThing.setSeed(rc.getRobot().getID());
		
		while(true){
			try{
				if(rc.getType()==RobotType.SOLDIER)
				{
					if (rc.getRobot().getID() < 120)
					{
						runPastrBuilder(farm1 = new MapLocation(rc.getMapWidth(), (rc.getMapHeight()/2)));
					}
					else if (rc.getRobot().getID() > 120 && rc.getRobot().getID() < 210 && rc.sensePastrLocations(rc.getTeam()).length > 0)
					{
						runTowerBuilder(rc.sensePastrLocations(rc.getTeam())[0]);
					}
//					else if (rc.getRobot().getID() < 120)
//					{
//						runPastrBuilder(farm1 = new MapLocation(rc.getMapWidth(), (rc.getMapHeight()/2)));
//					}
//					else if (rc.getRobot().getID() > 120 && rc.getRobot().getID() < 210 && rc.sensePastrLocations(rc.getTeam()).length > 0)
//					{
//						runTowerBuilder(rc.sensePastrLocations(rc.getTeam())[0]);
//					}
					else
					{
						runSoldier();
					}
				}
				
				else if(rc.getType()==RobotType.NOISETOWER)
				{
					runNoisetower();
				}
				else if(rc.getType()==RobotType.HQ)
				{
					runHeadquarters();
				}
				
				
				rc.yield();
			}catch (Exception e){
				e.printStackTrace();
			} //end catch
		} //end infinite loop while
	} //end run()

	private static void runPastrBuilder(MapLocation destination) throws GameActionException 
	{
		//attacking
		attackEnemiesInRange();
		
		cowsOnMap = rc.senseCowGrowth();
		if (cowsOnMap[rc.getMapWidth()-1][(rc.getMapHeight()/2)] >= 1)
		{
			if (rc.getLocation().equals(destination) || rc.getLocation().isAdjacentTo(destination) )
			{
				rc.construct(RobotType.PASTR);
			}
			else
			{
				//movement
				Movement movementInstance = new Movement();
				movementInstance.moveTowardsLocationBuglike(rc, destination); //Should probably set this destination up to be whichever 
			}																  //is farther from enemy HQ, or some other similar thing.
		}
		else
		{
			Movement.moveTowardsLocationBuglike(rc, destination);
		}
	} //end runPastrBuilder()
	
	private static void runTowerBuilder(MapLocation destination) throws GameActionException 
	{
		//attacking
		attackEnemiesInRange();
		
//		
		cowsOnMap = rc.senseCowGrowth();
		if (cowsOnMap[rc.getMapWidth()-1][(rc.getMapHeight()/2)] >= 1)
		{
			if (rc.getLocation().isAdjacentTo(destination) )
			{
				rc.construct(RobotType.NOISETOWER);
			}
			else
			{
				//movement
				Movement movementInstance = new Movement();
				movementInstance.moveTowardsLocationBuglike(rc, destination); //Should probably set this destination up to be whichever 
			}																  //is farther from enemy HQ, or some other similar thing.
		}
		else
		{
			Movement.moveTowardsLocationBuglike(rc, farm1);
		}
		
		
	} //end runTowerBuilder()
	
	private static void runSoldier() throws GameActionException 
	{
		
		//attacking
		attackEnemiesInRange();
		
		//movement

		//Movement.moveRobotRandomly(rc);
		
		//generate a route to the enemy HQ
		
		if(!routeMapped){	//this is temporary code I used during testing to ensure each robot only generated the route once. We'll want to replace this with a function that generates new routes when they're needed
			route = pathToGoal(rc.getLocation(), rc.senseEnemyHQLocation()); //This is how we tell it to generate a path to some location. Path is returned as an arraylist of MapLocations.
			routeMapped = true;
		}
		
		
		if(!route.isEmpty()){ //if there are places to move in the route
			Direction directionToGoal = rc.getLocation().directionTo(route.get(0)); //Get the direction to the first Location in the arraylist (should be adjacent)
			if(rc.canMove(directionToGoal) && rc.isActive()){ //if active and can move
				rc.move(directionToGoal);					//move in that direction
				route.remove(0);						//then remove that MapLocation from the ArrayList
			} //end inner if
		} //end if
		
	} //end runSoldier()
	
	private static void runNoisetower() throws GameActionException 
	{
		if (noisetowerDirTracker%4 == 0) //Farm West.
		{
			if (rc.canAttackSquare(rc.getLocation().add(Direction.WEST, noisetowerFireTracker*2)))
			{
				rc.attackSquare(rc.getLocation().add(Direction.WEST, noisetowerFireTracker*2));
			}
			noisetowerFireTracker--;
			if (noisetowerFireTracker < 1)
			{
				noisetowerFireTracker = 4;
				noisetowerDirTracker++;
			}
		}
		else if (noisetowerDirTracker%4 == 1) //Farm North.
		{
			if (rc.canAttackSquare(rc.getLocation().add(Direction.NORTH, noisetowerFireTracker*2)))
			{
				rc.attackSquare(rc.getLocation().add(Direction.NORTH, noisetowerFireTracker*2));
			}
			noisetowerFireTracker--;
			if (noisetowerFireTracker < 1)
			{
				noisetowerFireTracker = 4;
				noisetowerDirTracker++;
			}
		}
		else if (noisetowerDirTracker%4 == 2) //Farm East.
		{
			if (rc.canAttackSquare(rc.getLocation().add(Direction.EAST, noisetowerFireTracker*2)))
			{
				rc.attackSquare(rc.getLocation().add(Direction.EAST, noisetowerFireTracker*2));
			}
			noisetowerFireTracker--;
			if (noisetowerFireTracker < 1)
			{
				noisetowerFireTracker = 4;
				noisetowerDirTracker++;
			}
		}
		else //Farm South
		{
			if (rc.canAttackSquare(rc.getLocation().add(Direction.SOUTH, noisetowerFireTracker*2)))
			{
				rc.attackSquare(rc.getLocation().add(Direction.SOUTH, noisetowerFireTracker*2));
			}
			noisetowerFireTracker--;
			if (noisetowerFireTracker < 1)
			{
				noisetowerFireTracker = 4;
				noisetowerDirTracker++;
			}
		}
		
		
	} //end runNoisetower()
	
	private static void runHeadquarters() throws GameActionException 
	{
		Direction spawnDir = getFirstEmptySquareClockwiseFromTop();
		
		attackEnemiesInRange();
		
		if(rc.isActive()&&rc.senseRobotCount()<GameConstants.MAX_ROBOTS&&spawnDir!=Direction.NONE){
			rc.spawn(spawnDir);
			robotsProduced++;
		}
	} //end runHeadquarters()
	
	private static ArrayList<MapLocation> pathToGoal(MapLocation start, MapLocation goal) {
		int mapHeight = rc.getMapHeight();
		int mapWidth = rc.getMapWidth();
		
		MapLocation[][] origins = new MapLocation[mapWidth][mapHeight];
		for(int i=0; i<mapWidth; i++){
			for(int j=0; j<mapHeight; j++){
				origins[i][j] = null;
			}//end inner for
		} //end outer for
		Set<MapLocation>front = new HashSet<MapLocation>();
		
		MapLocation[] adjacentSquares = findAdjacent(start);
		for(int i=0; i < adjacentSquares.length; i++){
			TerrainTile terrainAtLocation = rc.senseTerrainTile(adjacentSquares[i]);
			if(terrainAtLocation == TerrainTile.NORMAL || terrainAtLocation == TerrainTile.ROAD){
				front.add(adjacentSquares[i]);
			}//end if
		}//end for				//done adding starting squares to front
		while(true){
			MapLocation bestOption = findBestOption(front, goal);;
			front.remove(bestOption);
			adjacentSquares = findAdjacent(bestOption);
			for(int i=0; i < adjacentSquares.length; i++){
				TerrainTile terrainAtLocation = rc.senseTerrainTile(adjacentSquares[i]);
				if((terrainAtLocation == TerrainTile.NORMAL || terrainAtLocation == TerrainTile.ROAD) && adjacentSquares[i] != rc.senseHQLocation() && origins[adjacentSquares[i].x][adjacentSquares[i].y] == null){
					front.add(adjacentSquares[i]);
					origins[adjacentSquares[i].x][adjacentSquares[i].y] = bestOption;
				} //end if
			} //end for
			
			if(bestOption.isAdjacentTo(goal)){
				System.out.println("Route calculated!");
				break;
			}//end if
		}//end while
		System.out.println("Route mapped!");
		
		ArrayList<MapLocation> route = new ArrayList<MapLocation>();
		MapLocation currentPosition = goal;
		route.add(currentPosition);
		while(!currentPosition.isAdjacentTo(start)){
			currentPosition = origins[currentPosition.x][currentPosition.y];
			route.add(currentPosition);
		}//end while
		
		Collections.reverse(route); //reverse the arraylist into the expected order
		return route;
	}//end pathToGoal()
	
	private static MapLocation findBestOption(Set<MapLocation> front, MapLocation goal){
		MapLocation bestPosition = null;
		float distanceOfBestPosition = Float.MAX_VALUE;
		for(MapLocation i : front){
			float distance = i.distanceSquaredTo(goal);
			if(distance < distanceOfBestPosition){
				distanceOfBestPosition = distance;
				bestPosition = i;
			}//end if
		}//end for
		
		return bestPosition;
	} //end findBestOption
	
	private static MapLocation[] findAdjacent(MapLocation location){
		MapLocation[] array = new MapLocation[8];
		array[0] = location.add(0,1); //add North
		array[1] = location.add(1,1); //add Northeast
		array[2] = location.add(1,0); //add East
		array[3] = location.add(1,-1); //add Southeast
		array[4] = location.add(0,-1); //add South
		array[5] = location.add(-1,-1); //add Southwest
		array[6] = location.add(-1,0); //add West
		array[7] = location.add(-1,1); //add Northwest
		return array;
	} //end findAdjacent()
	
	private static void attackEnemiesInRange() throws GameActionException 
	{
		Robot[] enemyRobotsInRange = rc.senseNearbyGameObjects(Robot.class, 10, rc.getTeam().opponent());
		if(enemyRobotsInRange.length > 0) {
			Robot target = enemyRobotsInRange[0];
			RobotInfo targetInfo;
			targetInfo = rc.senseRobotInfo(target);
			if(rc.isActive() && targetInfo.type != RobotType.HQ) {
				rc.attackSquare(targetInfo.location);
			} //end inner if
		} //end outer if
//		else { //no enemies in range, so build a tower
//			Robot[] pastrsWithinRange = rc.senseNearbyGameObjects(Robot.class, 9, null);
//			if(randomThing.nextDouble() < 0.03 && rc.sensePastrLocations(rc.getTeam()).length < 6 && pastrsWithinRange.length < 1) {
//				rc.construct(RobotType.PASTR);
//			}//end if
//		}//end else
	} //end attackEnemiesInRange()
	
	
	
	private static void moveTowardsLocationDirectly(MapLocation destination) throws GameActionException 
	{
		Direction chosenDir = rc.getLocation().directionTo(destination);
		if(rc.isActive() && rc.canMove(chosenDir)) {
			rc.move(chosenDir);
		} 
	} //end moveTowardsLocationDirectly()
	
	// Keep this method checking canMove and not if the square is empty (Void squares)
	private static Direction getFirstEmptySquareClockwiseFromTop() throws GameActionException 
	{
		Direction returnDir = Direction.NORTH_WEST; //Start arbitrarily with NorthWest
		int dirChangeCount = 0;
		while (!rc.canMove(returnDir) && dirChangeCount < 8) //If the square is full, 
		{					     //and we haven't checked all the squares yet,
			returnDir = returnDir.rotateRight(); //check the next square, clockwise,
			dirChangeCount++;                    //and increment the counter
		}
		if(dirChangeCount>=8)
		{
			return Direction.NONE; //If all the squares are full
		}
		else 
		{
			return returnDir; //Returns the first empty square detected
		}
	} //end getFirstEmptySquareClockwiseFromTop()
} //end RobotPlayer class
